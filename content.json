{"meta":{"title":"ZQ's Blog","subtitle":"菜还不努力，那就等死吧","description":null,"author":"张祺","url":"https://zhangqipangzi.github.io/ZhangQi.github.io"},"pages":[],"posts":[{"title":"关于Integer判断是否相等的一个有意思的地方","slug":"关于Integer判断是否相等的一个有意思的地方","date":"2018-04-22T12:44:05.879Z","updated":"2018-04-22T12:43:52.620Z","comments":true,"path":"2018/04/22/关于Integer判断是否相等的一个有意思的地方/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/22/关于Integer判断是否相等的一个有意思的地方/","excerpt":"今日我在网上看到了一段很有意思的代码，拿出来与大家分享一波：","text":"今日我在网上看到了一段很有意思的代码，拿出来与大家分享一波：1234567891011public static void main(String[] args) &#123; Integer a, b; a = 1000; b = 1000; System.out.print(a == b); a = 100; b = 100; System.out.print(a == b); &#125; 我们知道在java中，“==”在判断引用数据类型时，是通过判断两变量的hashcode是否相同来返回true或false，而在这段代码中我们可以看到a与b都是Integer类型，那么无论给他俩赋的值是否相同，两次判断结果都应是false，但事实上结果是这样的：false true,这是为什么呢？ 我们知道，a = 1000与a = Integer.valueOf(1000)是相同的，那么我们便在valueOf()这个方法中寻找答案:12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125;最关键的一点出来了，这个方法中有一个IntegerCache类，这是一个在Integer内部的私有静态类，它有这么一个作用，那就是它缓存了-128到127内的整数，这样就好理解了，当给一个Integer对象赋-128到127之间的整数时，实际是从缓存中拿取了值，由于这些值在缓存中只有一份，那么这两个引用只能指向同一个实例了，这就是第二个a与b相同的原因。","categories":[],"tags":[]},{"title":"面向对象的三个基本特征（java）","slug":"面向对象的三个基本特征（java）","date":"2018-04-19T15:47:03.248Z","updated":"2018-04-22T12:46:17.668Z","comments":true,"path":"2018/04/19/面向对象的三个基本特征（java）/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/19/面向对象的三个基本特征（java）/","excerpt":"#封装 封装是面向对象里的一种最基本的特征，也是对象和类最主要的特征，众所周知，对象是类的一个实例化，对象实例的就是类中的数据成员及方法，而封装指的就是将这些方法及数据成员封存到类里去，外部若想访问这个类，只能通过对象或者是可调用它的其他类（也包括这个类本身）。","text":"#封装 封装是面向对象里的一种最基本的特征，也是对象和类最主要的特征，众所周知，对象是类的一个实例化，对象实例的就是类中的数据成员及方法，而封装指的就是将这些方法及数据成员封存到类里去，外部若想访问这个类，只能通过对象或者是可调用它的其他类（也包括这个类本身）。 #继承 继承是面向对象最令人称道的功能之一，它指的是当前要被继承的类（父类，基类）的所有数据成员及方法被实现继承这个功能的类（子类，派生类）所接收（即子类所占用的空间包含父类），注意：父类的私有成员也是被继承的，只是不能通过子类直接访问，可以通过父类方法访问（例如set，get方法）。java中只能单继承，但可以通过继承接口来实现多继承的功能。 #多态 多态也是面向对象里的一个很强大的功能，所谓多态其实是为了减少代码的重用，即设置一个基类，这个类中有一些通用方法（抽象方法），而这种通用方法是很多类所要持有（或实现）的，到这感觉会跟继承一样，但多态指的是一个调多个，即通过基类的引用来调用其余继承它的类内的对基类方法的重写方法，至于基类引用究竟调那个子类，这就是运行期类型识别（RTTI），即运行时通过实际创建的类的类型来确定调用关系。","categories":[],"tags":[]},{"title":"try块的一个需要注意的地方","slug":"try块的一个需要注意的地方","date":"2018-04-19T15:27:28.895Z","updated":"2018-04-19T15:29:15.756Z","comments":true,"path":"2018/04/19/try块的一个需要注意的地方/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/19/try块的一个需要注意的地方/","excerpt":"首先看一段代码：","text":"首先看一段代码：12345678910111213public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;return value of getValue(): &quot; + getValue()); &#125; public static int getValue() &#123; try &#123; return 0; &#125; finally &#123; return 1; &#125; &#125; &#125; 这是今个我在牛客上看到的一道题，以往只知道在try块中无论try内语句是否执行，finally内的语句总会执行的，而在做此题时由于try内有return，所以以为会在此处中断方法，即最后的结果为0，但是运行结果却是return value of getValue(): 1，这是为什么呢？ 根据jvm规范，在执行完try语句后，若有返回值，则将此返回值先存入局部变量表中，再执行finally语句，执行完finally语句后返回先前保存在局部变量表中的值，但这里存在一个问题,就i是如果在执行finally语句时，finally语句内有return，那么就会在此处中断方法，而先前存入局部变量表中的值就无法返回，所以此题返回的是1。","categories":[],"tags":[]},{"title":"abstract浅谈及与哪些关键字不能共存（java）","slug":"abstract浅谈及与哪些关键字不能共存（java）","date":"2018-04-12T07:33:39.919Z","updated":"2018-04-22T12:43:14.838Z","comments":true,"path":"2018/04/12/abstract浅谈及与哪些关键字不能共存（java）/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/12/abstract浅谈及与哪些关键字不能共存（java）/","excerpt":"首先解释下abstract，abstract（抽象）可以修饰类、方法。","text":"首先解释下abstract，abstract（抽象）可以修饰类、方法。 abstract修饰类时代表这个类为抽象类，即这个类不能被实例化，那么它有什么用呢，即被继承（实际上这也是它最主要的作用），抽象类中可以不含抽象方法。 abstract也可以修饰方法，此时该方法为抽象方法，它不需要实现（事实上也无法对此方法在抽象类内进行实现），如这种public abstract void fun();，抽象方法只能在子类通过重写进行实现，若一个类含抽象方法，那么它肯定是抽象类。 下面对与abstract不能共存的三个关键字总结一下： private： 因为private修饰的方法无法被继承，故无法与abstract共存，如要执意共存（private abstract void fun();），编译器会报这个The abstract method fun in type Test1 can only set a visibility modifier, one of public or protected，即只能用public，protected修饰（其实不写也行，默认包内访问权限）。 final 用final修饰的类代表此类不可被继承，与abstract修饰的类相互矛盾，所以不能共存，而用final修饰的方法代表这个方法不能被重写，所以也无法与abstract共存。 static 静态，用静态修饰的方法代表是属于类所有的，这个方法不能被重写（提一句，这个方法可以在子类内被重定义），所以它也无法与abstract共存。","categories":[],"tags":[]}]}