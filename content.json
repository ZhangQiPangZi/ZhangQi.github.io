{"meta":{"title":"ZQ's Blog","subtitle":"菜还不努力，那就等死吧","description":null,"author":"张祺","url":"https://zhangqipangzi.github.io/ZhangQi.github.io"},"pages":[],"posts":[{"title":"Java集合总结（List）","slug":"Java集合总结(List)","date":"2018-06-07T11:36:25.721Z","updated":"2018-06-07T11:40:50.308Z","comments":true,"path":"2018/06/07/Java集合总结(List)/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/06/07/Java集合总结(List)/","excerpt":"#这么菜还不努力","text":"#这么菜还不努力[TOC] 此篇文章集合结构图转自http://www.cnblogs.com/skywang12345/p/3323085.html #Collection Collection是一个接口，它是一个高度抽象的集合，主要有List和Set两个抽象集合继承它，集合中最基本的操作增删改查，获取集合大小等都在此定义； 它的类名定义为public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;，可以看出Collection接口继承了Iterable这个接口，由于Collection中有一个iterator()函数，我们可以通过Iterator迭代器来遍历集合（List还有一个功能更多的迭代器，ListIterator）##AbstractCollection public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; 是一个实现了Collection中除了iterator()和size()方法之外大部分方法的抽象类（jdk1.8），它的存在意义在于方便其他类实现Collection，如ArrayList只需继承AbstractCollection即可实现Collection中大部分功能。##List public interface List&lt;E&gt; extends Collection&lt;E&gt; List是一个继承于Collection的接口，它是有序存储（按插入元素的顺序存储）的，且存储的元素可以重复。List中每一个元素都有一个索引，第一个元素的索引是0，之后元素索引按存入顺序依次加一。##AbstractListpublic abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; AbstractList是一个实现了List接口的抽象类，它实现了List中的大部分方法，以此方便其他类继承List，AbstractList也继承了AbstractCollection，它实现了iterator方法及ListIterator。#ArrayList ##ArrayList介绍public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList是一个List的具体实现类，它的底层主要由数组（动态数组组成）,ArrayList继承了AbstractList类，提供了最基本的增删改查，比较等功能，它实现了RandomAccess接口，这意味着ArrayList可以由元素序号快速获取元素（与数组相似），ArrayList也可实现序列化。 特别的，ArrayList是线程不安全的，也就是说在多线程使用时需要进行同步处理，ArrayList的元素是有序存储的，它允许元素值为null.##ArrayList源码解析### 数据成员介绍 private static final int DEFAULT_CAPACITY = 10; 容量的初始值为10； transient Object[] elementData; 这实则上是一个动态数组，它的初值由构造器赋值，若赋值为空数组，则默认容量为10，且这个数组不参与序列化； private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 这是两个空常量数组，都是用于对空对象的实例化，不同的是下面这个是在空构造里的空数组。 private int size; size表示集合中的元素个数。### 方法介绍#### 构造方法1. 空构造方法123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 这个空构造函数代表若new对象时没有传参数，那么构造方法便会将空常量数组赋给elementData ,此时ArrayList的默认容量为10，这里似乎并没有给出具体的空间大小，因为此时的开辟空间是在add（）中实现的。 2. 指定容量的构造方法12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; 这个构造函数有一个给定的参数，若这个参数大于0，则将参数大小作为容量来初始化底层的elementData数组，若为0，则将空常量数组赋给底层数组，若两者都不满足，则抛出非法初始容量。 3. 将一个Collection赋给ArrayList1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 此构造函数参数为容器Collection，首先将它转为数组赋给底层数组，再对底层数组进行判断，若数组不为Object[]，则拷贝一个Object[]赋给底层数组，若容器容量为0，则将空常量数组赋给底层数组。#### 增加元素 1. add(E e)12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; add方法为集合中添加元素的方法，这是第一种添加方法，即每次往集合末尾添加一个元素，这个方法第一行为ensureCapacityInternal方法，下面我们来分析一下这个方法：1234567private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; 这个方法主要作用为判断底层数组是否为默认空常量数组，即实例化时调用的构造方法为空构造，若满足条件，则开辟一块容量为默认值（10）或minCapacity（即为size+1）的空间给ArrayList，再调用ensureExplicitCapacity方法来判断集合是否需要扩容，下面我们看下ensureExplicitCapacity这个方法：1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 这个方法只有一个作用，那就是判断当前数组是否需要扩容，如果minCapacity大于原数组的大小，那就需要调用扩容方法（grow）来进行扩容，我们将会在介绍完add方法之后进行介绍。此中的modCount为修改次数（注意：它不能被序列化）2. add(int index, E element)123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; 此方法为给定位置将元素插入，实现原理与往数组中插入元素相同，都是将要插入元素后的元素后移，再进行插入，只不过这里的后移操作交由数组拷贝方法完成，拷贝后的新数组将原数组index之后的所有元素后移一个单位，然后再执行插入操作。3. addAll(Collection&lt;？ extends E&gt; c)12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; 这个方法是将一个Collection添加至ArrayList中，首先将这个Collection转化为数组，再判断ArrayList是否需要扩容，再将这个集合添加至集合末尾。 还有一个方法是往指定位置插入集合，这里我就不再叙述了。#### ArrayList的扩容机制12345678910111213private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; ArrayList中的扩容时的新容量遵循“新的容量=旧的容量（原数组的长度）+旧的容量/2”，然后再由扩容方法判断具体容量为多少，第一种为新扩容后容量太小，则将其容量扩为minCapacity，第二种为扩容后容量太大（此时以达到扩容极限，无法继续扩容），则调用hugeCapacity方法来进行最终容量的确认，下面我们来看看这个方法：1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;我们可以看到这里用到了一个三目，使新的容量最大不会超过MAX_VALUE，也就是这个“0x7fffffff”，事实上，这也是ArrayList所能达到的最大容量。最后再将新的容量作为新数组的长度来申请空间以完成扩容。#### 移除元素1. 移除指定位置的元素1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 这个方法为移除指定位置的元素，它的实现方法与数组移除元素相同，即将要删除元素后的元素向前移动一个单位，这里的numMoved为前移元素的个数，2. 移除指定值第一次出现位置上的元素12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 此方法删除的是给定值第一次出现位置的元素，首先判断给定值是否为空，可能有人会在这里问，这个判断是不是多此一举了，好像只要一个循环就可以了，但java中拿equals判断null会出问题，当给定的值不为null时，当然是false，但假若是null，则会报空指针异常（神奇吧），所以此处只能分开来写（==当然也不行了，它还会判断hashcode是否相同），下面我们介绍在这个方法中实现删除的fastRemove方法。3. 快速删除12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 这个方法功能如它的名字一样，快速删除，不需判断位置的合法性（因为在调用它的方法中已经判断过或者说确认过位置的合法性），也不需要返回被删除的元素，它所需要做的只有删除元素，这个方法实现很简单，计算出前移元素的个数，然后前移覆盖掉删除元素，最后将数组长度改正确即可，注意，此为私有方法，它主要为其它删除方法服务。4. 删除给定区间的元素12345678910111213protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; 这个方法实现原理很简单，就是将给定区间后的元素向前移动以覆盖删除元素，注意最后要更改集合元素个数。5. 批量删除元素1234public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; 首先此方法需要判断要删除集合的合法性，即是否为空，然后调用batchRemove()方法进行批量移动以进行删除，下面是batchRemove()方法详解。6. 批量移动元素12345678910111213141516171819202122232425262728private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; 这个方法乍一看很多，但其实很简单，首先w是新数组（即删除所需元素之后的数组）的长度，try块内的作用是将不需删除的元素保存下来，放入数组中，而finally中的第一个if语句是处理当出现异常时，将出现异常的元素（r）之后的元素复制到新数组中，而第二个if的作用指的是将w之后的元素置空，以方便GC进行回收，提高效率。#### 修改元素1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; ArrayList由于底层是数组，所以在增删元素方面效率较低（牵扯到modCount的修改及数组的复制），而在改查方面由于数组的特性，所以较为方便。 此方法就是由传入的位置及元素来修改原集合内的元素，需要注意的是，此方法并不牵扯到modCount的修改。#### 查找元素1. 通过元素查找位置12345678910111213141516171819202122232425public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 这两个方法一个是从前往后查找元素，一个是从后往前，需要注意的是查找元素也不涉及modCount的修改。2. 通过位置查找元素123456789public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;E elementData(int index) &#123; return (E) elementData[index]; &#125;#### 清空元素123456789public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; 没什么好说的，注意会修改modCount。#### 迭代器Iterator1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125;private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 这个私有内部类Itr实现了Iterator，其中hashnext方法的作用是判断迭代是否完成，next方法则是迭代下一个元素，这个方法的第一句调用了checkForComodification()，checkForComodification()的作用是判断是否存在并发修改（即ArrayList调用了非Itr内部类的增删元素的方法），next方法中的第一个if是判断是否有越界（即cursor已到达集合尾部），第二个if则是判断是否有并发修改从而导致集合结构变化，使得迭代器与集合不同步，从而产生越界。 接下来我们来研究下为何会产生ConcurrentModificationException()异常，我们知道，在Itr外部增加或删除元素时，会修改modCount，只有调用Itr这个内部类时，才会将修改过的modCount赋给expectedModCount，而如果在迭代过程中出现了调用ArrayList自身的非Itr的add或remove方法，那么在修改modCount时并不会修改expectedmodCount，从而对迭代过程造成影响，所以会产生ConcurrentModificationException()异常（这就是fail-fast，快速失败）。 而remove方法实现了在迭代过程中删除元素，lastRet代表的是上一个迭代的元素，而cursor代表将要迭代的元素，为什么这个方法不会引发ConcurrentModificationException()呢？因为expectedModCount在这个方法中被修改为与当前的modCount一样的值。 此外ArrayList还实现了一个private class ListItr extends Itr implements ListIterator&lt;E&gt; ，这个迭代器增加了向前遍历public E previous()及增加元素public void add(E e) 、修改元素public void set(E e) 都非常有趣，有兴趣的可以去瞅瞅，但需要注意的是每当修改集合结构时，都需要修改expectedModCount，以此保证迭代内外一致性。# LinkedList## LinkedList介绍 从图中可以看出LinkedList与ArrayList的一个区别，ArrayList是直接继承于AbstractList，而LinkedList是继承自AbstractSequentialList，并且LinkedList还实现了Deque接口，这表示LinkedList可以作为队列来使用，它与ArrayList的另一个区别是底层的实现，LinkedList底层为双向链表，所以在增删元素上它有天然的优势，而不用像ArrayList涉及到数组的复制，但在改查元素上就没有ArrayList那么便捷了，因为它涉及元素的定位。 LinkedList允许元素为null，与ArrayList相同，它也是线程不安全的。## LinkedList源码解析### 数据成员介绍transient int size = 0;元素数量（结点数量）transient Node&lt;E&gt; first;链表头结点，这里的Node类会在之后说明transient Node&lt;E&gt; last;链表尾结点### 方法介绍#### 构造方法在看构造方法之前我们先来看下Node类。1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 这是一个私有内部类，它的作用是构建这个链表的每一个结点，从此可以看出，这是一个双向链表。1. 空构造12public LinkedList() &#123; &#125; 这个空构造其实就是建一个空的双向链表。2. 将一个集合作为参数1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 这个构造为以现有集合元素构建一个LinkedList，首先先创建一个空链表，再将Collection作为参数添加到链表中，具体方法addAll()之后介绍。#### 增加元素1. addAll1234567891011121314151617181920212223242526272829303132333435363738394041public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; 接着上文的构造说起，首先第一个addAll方法是作为没有传入插入元素位置时，自动插入到尾部的作用而存在的，真正实现是在第二个方法中。 第二个addAll是以index为插入下标来进行元素的插入，首先第一步是喜闻乐见的检查插入位置合法性，然后与ArrayList批量插入一样，将Collection转为数组，其中numNew是新增元素的数量，然后有两个结点pred，succ，这两个结点是作为index这个位置要插入结点的直接前驱和直接后继的，接着就是初始化pred和succ，如果要插入在集合末尾，那么就将直接后继succ置空，直接前驱pred为原集合的最后一个结点，如果是其他位置的话，就将succ置为现在index位置上的结点，pred为succ的前一个结点，这里涉及到一个非常巧妙的查找结点的方法，请看：123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; 这个方法巧妙的是它将index的位置做了一个判断，如果index在前半部分，那么就从头结点开始遍历，反之从尾结点开始。 我们接着说，接下来就是插入步骤，由于是批量插入，所以此处用了一个加强循环，这个循环的作用就是将每个结点与其直接前驱结点（pred）连接起来（注意插入要分为头插与中间尾插），然后就是循环之后，将最后一个插入的结点与直接后继结点（succ）连接起来，这里注意要分为尾部与中间，尾部只需修改尾结点，中间要注意此时的pred指向插入的最后一个结点。 最后修改size与modCount（与ArrayList相同哒）。2. add(E e)123456789101112131415public boolean add(E e) &#123; linkLast(e); return true; &#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; 插入单个元素，默认插入尾部，即调用linklast这个方法，其中l是尾结点，插入时要注意这个LinkedList是否是一个空链表，还有就是要修改size与modCount。3. add(int index, E element)1234567891011121314151617181920public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; 这个其实没啥好说的，就是给定位置插入结点，注意插入要分头结点还是其他结点，还有要修改size和modCount。 还有两个增加元素的方法addFirst(E e) 和addLast(E e) ,见名知意，没啥子好说的。 至此添加元素的方法就介绍完了，与ArrayList相比，无疑提高了效率，但在其中查找对应位置的结点（node(int index)）时，虽然巧妙的运用了双向链表的特性，但仍要遍历链表，这是LinkedList较ArrayList的缺点。#### 删除元素1. remove(Object o)123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; 此方法为给定一个需要删除的元素，然后从头结点遍历整个LinkedList（还有个是从尾结点往前遍历的removeLastOccurrence(Object o)），找到它，并调用unlink删除它，下面我们来看看unlink这个方法。12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; 这个方法就是常规的从一个双向链表中删除一个结点，首先修改x的直接前驱结点的后继指向，注意头结点只需修改头指针first，还有就是将x的前驱指向置为null（方便垃圾回收），然后修改x的直接后继结点的前驱指向，注意尾结点只需修改尾结点last，照例，将x的next置null，最后将x的item置为null，并且修改结点个数（size）和modCount，将被删除的元素返回。2. remove(int index)1234public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index)); &#125; 这个删除方法是给定结点位置，找到并删除它，第一步，喜闻乐见，检查位置合法性，然后先调用node（）这个方法，找到这个结点并把它作为参数传给unlink（），删除它。 还有两个方法removeFirst() 和 removeLast()，都是见名之意，在此不再赘述。 总的来说，LinkedList删除元素比ArrayList提高了太多效率，但是仍要注意modCount的修改。#### 修改元素set(int index, E element)1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; &#125; 给定位置及要修改的元素，嗯，第一步检查位置合法性，然后调用node(int index) 找到对应的结点，然后先将旧值保存起来，再将新值赋给结点数据域，最后将旧值返回。#### 查找元素1. get12345678910111213141516public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125;public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; 这三个get方法分别是获取头结点的数据域，尾结点的数据域，以及指定位置的结点的数据域，注意获取头尾结点时要判断LinkedList是否为空。2. indexOf12345678910111213141516171819202122232425262728293031323334public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125; 这两个方法都是通过给定元素去查找相应的位置，由于List允许有重复元素的存在，所以分为两个方法，第一个方法为从头结点向后遍历查找元素，第二个方法则是从尾结点向前查找元素。 在通过元素查找位置时，LinkedList与ArrayList都需进行遍历查找，但在通过位置查找元素时，ArrayList明显优于LinkedList。#### 清空元素12345678910111213141516public void clear() &#123; // Clearing all of the links between nodes is &quot;unnecessary&quot;, but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++; &#125; 这个方法是清空整个LinkedList，注意头结点first与尾结点last及size、modCount都要修改。#### 迭代器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index); &#125;private class ListItr implements ListIterator&lt;E&gt; &#123; private Node&lt;E&gt; lastReturned; private Node&lt;E&gt; next; private int nextIndex; private int expectedModCount = modCount; ListItr(int index) &#123; // assert isPositionIndex(index); next = (index == size) ? null : node(index); nextIndex = index; &#125; public boolean hasNext() &#123; return nextIndex &lt; size; &#125; public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; &#125; public boolean hasPrevious() &#123; return nextIndex &gt; 0; &#125; public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item; &#125; public int nextIndex() &#123; return nextIndex; &#125; public int previousIndex() &#123; return nextIndex - 1; &#125; public void remove() &#123; checkForComodification(); if (lastReturned == null) throw new IllegalStateException(); Node&lt;E&gt; lastNext = lastReturned.next; unlink(lastReturned); if (next == lastReturned) next = lastNext; else nextIndex--; lastReturned = null; expectedModCount++; &#125; public void set(E e) &#123; if (lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; &#125; public void add(E e) &#123; checkForComodification(); lastReturned = null; if (next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; action.accept(next.item); lastReturned = next; next = next.next; nextIndex++; &#125; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; LinkedList只有ListIterator（所以这个内部类好长啊。。。）。 介绍一下，lastReturned 当前要返回的结点，next 下一个结点，然后和ArrayList一样，有期望修改数expectedModCount，需要注意的是两个三目运算符，第一个在构造里的，是找到index位置（默认为0）的结点，如果index为size，那么就给它置为null，第二个是在向前遍历里，如果当前的next为null，那么代表它的直接前驱为尾结点，否则就赋为它的前一个结点。 还有，由于它包含了remove方法及add方法，所以LinkedList也是有快速失败机制的。","categories":[],"tags":[]},{"title":"关于Integer判断是否相等的一个有意思的地方","slug":"关于Integer判断是否相等的一个有意思的地方","date":"2018-04-22T12:44:05.879Z","updated":"2018-04-22T12:43:52.620Z","comments":true,"path":"2018/04/22/关于Integer判断是否相等的一个有意思的地方/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/22/关于Integer判断是否相等的一个有意思的地方/","excerpt":"今日我在网上看到了一段很有意思的代码，拿出来与大家分享一波：","text":"今日我在网上看到了一段很有意思的代码，拿出来与大家分享一波：1234567891011public static void main(String[] args) &#123; Integer a, b; a = 1000; b = 1000; System.out.print(a == b); a = 100; b = 100; System.out.print(a == b); &#125; 我们知道在java中，“==”在判断引用数据类型时，是通过判断两变量的hashcode是否相同来返回true或false，而在这段代码中我们可以看到a与b都是Integer类型，那么无论给他俩赋的值是否相同，两次判断结果都应是false，但事实上结果是这样的：false true,这是为什么呢？ 我们知道，a = 1000与a = Integer.valueOf(1000)是相同的，那么我们便在valueOf()这个方法中寻找答案:12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125;最关键的一点出来了，这个方法中有一个IntegerCache类，这是一个在Integer内部的私有静态类，它有这么一个作用，那就是它缓存了-128到127内的整数，这样就好理解了，当给一个Integer对象赋-128到127之间的整数时，实际是从缓存中拿取了值，由于这些值在缓存中只有一份，那么这两个引用只能指向同一个实例了，这就是第二个a与b相同的原因。","categories":[],"tags":[]},{"title":"面向对象的三个基本特征（java）","slug":"面向对象的三个基本特征（java）","date":"2018-04-19T15:47:03.248Z","updated":"2018-04-22T12:46:17.668Z","comments":true,"path":"2018/04/19/面向对象的三个基本特征（java）/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/19/面向对象的三个基本特征（java）/","excerpt":"#封装 封装是面向对象里的一种最基本的特征，也是对象和类最主要的特征，众所周知，对象是类的一个实例化，对象实例的就是类中的数据成员及方法，而封装指的就是将这些方法及数据成员封存到类里去，外部若想访问这个类，只能通过对象或者是可调用它的其他类（也包括这个类本身）。","text":"#封装 封装是面向对象里的一种最基本的特征，也是对象和类最主要的特征，众所周知，对象是类的一个实例化，对象实例的就是类中的数据成员及方法，而封装指的就是将这些方法及数据成员封存到类里去，外部若想访问这个类，只能通过对象或者是可调用它的其他类（也包括这个类本身）。 #继承 继承是面向对象最令人称道的功能之一，它指的是当前要被继承的类（父类，基类）的所有数据成员及方法被实现继承这个功能的类（子类，派生类）所接收（即子类所占用的空间包含父类），注意：父类的私有成员也是被继承的，只是不能通过子类直接访问，可以通过父类方法访问（例如set，get方法）。java中只能单继承，但可以通过继承接口来实现多继承的功能。 #多态 多态也是面向对象里的一个很强大的功能，所谓多态其实是为了减少代码的重用，即设置一个基类，这个类中有一些通用方法（抽象方法），而这种通用方法是很多类所要持有（或实现）的，到这感觉会跟继承一样，但多态指的是一个调多个，即通过基类的引用来调用其余继承它的类内的对基类方法的重写方法，至于基类引用究竟调那个子类，这就是运行期类型识别（RTTI），即运行时通过实际创建的类的类型来确定调用关系。","categories":[],"tags":[]},{"title":"try块的一个需要注意的地方","slug":"try块的一个需要注意的地方","date":"2018-04-19T15:27:28.895Z","updated":"2018-04-19T15:29:15.756Z","comments":true,"path":"2018/04/19/try块的一个需要注意的地方/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/19/try块的一个需要注意的地方/","excerpt":"首先看一段代码：","text":"首先看一段代码：12345678910111213public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;return value of getValue(): &quot; + getValue()); &#125; public static int getValue() &#123; try &#123; return 0; &#125; finally &#123; return 1; &#125; &#125; &#125; 这是今个我在牛客上看到的一道题，以往只知道在try块中无论try内语句是否执行，finally内的语句总会执行的，而在做此题时由于try内有return，所以以为会在此处中断方法，即最后的结果为0，但是运行结果却是return value of getValue(): 1，这是为什么呢？ 根据jvm规范，在执行完try语句后，若有返回值，则将此返回值先存入局部变量表中，再执行finally语句，执行完finally语句后返回先前保存在局部变量表中的值，但这里存在一个问题,就i是如果在执行finally语句时，finally语句内有return，那么就会在此处中断方法，而先前存入局部变量表中的值就无法返回，所以此题返回的是1。","categories":[],"tags":[]},{"title":"abstract浅谈及与哪些关键字不能共存（java）","slug":"abstract浅谈及与哪些关键字不能共存（java）","date":"2018-04-12T07:33:39.919Z","updated":"2018-04-22T12:43:14.838Z","comments":true,"path":"2018/04/12/abstract浅谈及与哪些关键字不能共存（java）/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/12/abstract浅谈及与哪些关键字不能共存（java）/","excerpt":"首先解释下abstract，abstract（抽象）可以修饰类、方法。","text":"首先解释下abstract，abstract（抽象）可以修饰类、方法。 abstract修饰类时代表这个类为抽象类，即这个类不能被实例化，那么它有什么用呢，即被继承（实际上这也是它最主要的作用），抽象类中可以不含抽象方法。 abstract也可以修饰方法，此时该方法为抽象方法，它不需要实现（事实上也无法对此方法在抽象类内进行实现），如这种public abstract void fun();，抽象方法只能在子类通过重写进行实现，若一个类含抽象方法，那么它肯定是抽象类。 下面对与abstract不能共存的三个关键字总结一下： private： 因为private修饰的方法无法被继承，故无法与abstract共存，如要执意共存（private abstract void fun();），编译器会报这个The abstract method fun in type Test1 can only set a visibility modifier, one of public or protected，即只能用public，protected修饰（其实不写也行，默认包内访问权限）。 final 用final修饰的类代表此类不可被继承，与abstract修饰的类相互矛盾，所以不能共存，而用final修饰的方法代表这个方法不能被重写，所以也无法与abstract共存。 static 静态，用静态修饰的方法代表是属于类所有的，这个方法不能被重写（提一句，这个方法可以在子类内被重定义），所以它也无法与abstract共存。","categories":[],"tags":[]}]}