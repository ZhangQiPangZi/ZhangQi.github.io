{"meta":{"title":"ZQ's Blog","subtitle":"菜还不努力，那就等死吧","description":null,"author":"张祺","url":"https://zhangqipangzi.github.io/ZhangQi.github.io"},"pages":[],"posts":[{"title":"面向对象的三个基本特征（java）","slug":"面向对象的三个基本特征（java）","date":"2018-04-12T07:14:06.000Z","updated":"2018-04-12T07:41:01.255Z","comments":true,"path":"2018/04/12/面向对象的三个基本特征（java）/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/12/面向对象的三个基本特征（java）/","excerpt":"#封装 封装是面向对象里的一种最基本的特征，也是对象和类最主要的特征，众所周知，对象是类的一个实例化，对象实例的就是类中的数据成员及方法，而封装指的就是将这些方法及数据成员封存到类里去，外部若想访问这个类，只能通过对象或者是可调用它的其他类（也包括这个类本身）。","text":"#封装 封装是面向对象里的一种最基本的特征，也是对象和类最主要的特征，众所周知，对象是类的一个实例化，对象实例的就是类中的数据成员及方法，而封装指的就是将这些方法及数据成员封存到类里去，外部若想访问这个类，只能通过对象或者是可调用它的其他类（也包括这个类本身）。 #继承 继承是面向对象最令人称道的功能之一，它指的是当前要被继承的类（父类，基类）的所有数据成员及方法被实现继承这个功能的类（子类，派生类）所接收（即子类所占用的空间包含父类），注意：父类的私有成员也是被继承的，只是不能通过子类直接访问，可以通过父类方法访问（例如set，get方法）。java中只能单继承，但可以通过继承接口来实现多继承的功能。 #多态 多态也是面向对象里的一个很强大的功能，所谓多态其实是为了减少代码的重用，即设置一个基类，这个类中有一些通用方法（抽象方法），而这种通用方法是很多类所要持有（或实现）的，到这感觉会跟继承一样，但多态指的是一个调多个，即通过基类的引用来调用其余继承它的类内的对基类方法的重写方法，至于基类引用究竟调那个子类，这就是运行期类型识别（RTTI），即运行时通过实际创建的类的类型来确定调用关系。","categories":[],"tags":[]},{"title":"abstract浅谈及与哪些关键字不能共存（java）","slug":"abstract浅谈及与哪些关键字不能共存（java）","date":"2018-04-12T07:14:06.000Z","updated":"2018-04-12T07:38:40.350Z","comments":true,"path":"2018/04/12/abstract浅谈及与哪些关键字不能共存（java）/","link":"","permalink":"https://zhangqipangzi.github.io/ZhangQi.github.io/2018/04/12/abstract浅谈及与哪些关键字不能共存（java）/","excerpt":"首先解释下abstract，abstract（抽象）可以修饰类、方法。","text":"首先解释下abstract，abstract（抽象）可以修饰类、方法。 abstract修饰类时代表这个类为抽象类，即这个类不能被实例化，那么它有什么用呢，即被继承（实际上这也是它最主要的作用），抽象类中可以不含抽象方法。 abstract也可以修饰方法，此时该方法为抽象方法，它不需要实现（事实上也无法对此方法在抽象类内进行实现），如这种public abstract void fun();，抽象方法只能在子类通过重写进行实现，若一个类含抽象方法，那么它肯定是抽象类。 下面对与abstract不能共存的三个关键字总结一下： private： 因为private修饰的方法无法被继承，故无法与abstract共存，如要执意共存（private abstract void fun();），编译器会报这个The abstract method fun in type Test1 can only set a visibility modifier, one of public or protected，即只能用public，protected修饰（其实不写也行，默认包内访问权限）。 final 用final修饰的类代表此类不可被继承，与abstract修饰的类相互矛盾，所以不能共存，而用final修饰的方法代表这个方法不能被重写，所以也无法与abstract共存。 static 静态，用静态修饰的方法代表是属于类所有的，这个方法不能被重写（提一句，这个方法可以在子类内被重定义），所以它也无法与abstract共存。","categories":[],"tags":[]}]}